Index: plugins/band_pass/BandPassPlugin.h
===================================================================
--- a/plugins/band_pass/BandPassPlugin.h	(revision 2332)
+++ b/plugins/band_pass/BandPassPlugin.h	(revision 2333)
@@ -84,23 +84,23 @@
      * Called when the parameter changed during pre-listen
      * @param frequency the frequency parameter in Hz
      */
-    void setFreqValue(qreal frequency);
+    void setFreqValue(double frequency);
 
-    void setBwValue(qreal bw);
+    void setBwValue(double bw);
 
 private:
 
     /** cutoff frequency [Hz] */
-    qreal m_frequency;
+    double m_frequency;
 
     /** last value of m_frequency */
-    qreal m_last_freq;
+    double m_last_freq;
 
     /** bandwidth value [Hz] */
-    qreal m_bw;
+    double m_bw;
 
     /** last value of m_bw */
-    qreal m_last_bw;
+    double m_last_bw;
 
 };
 
Index: plugins/band_pass/BandPass.h
===================================================================
--- a/plugins/band_pass/BandPass.h	(revision 2332)
+++ b/plugins/band_pass/BandPass.h	(revision 2333)
@@ -46,7 +46,7 @@
     virtual void goOn();
 
     /** @see TransmissionFunction::at() */
-    virtual qreal at(qreal f);
+    virtual double at(double f);
 
 signals:
 
@@ -82,7 +82,7 @@
      * @param freq normed frequency
      * @param R normed bandwidth
      */
-    void setfilter_2polebp(qreal freq, qreal R);
+    void setfilter_2polebp(double freq, double R);
 
 private:
 
@@ -90,15 +90,15 @@
     Kwave::SampleArray m_buffer;
 
     /** center frequency */
-    qreal m_frequency;
+    double m_frequency;
 
     /** bandwidth */
-    qreal m_bandwidth;
+    double m_bandwidth;
 
     /** structure with the filter coefficients */
     struct {
-	qreal cx,cx1,cx2,cy1,cy2;
-	qreal x,x1,x2,y,y1,y2;
+	double cx,cx1,cx2,cy1,cy2;
+	double x,x1,x2,y,y1,y2;
     } m_filter;
 
 };
Index: plugins/band_pass/BandPassDialog.h
===================================================================
--- a/plugins/band_pass/BandPassDialog.h	(revision 2332)
+++ b/plugins/band_pass/BandPassDialog.h	(revision 2333)
@@ -46,7 +46,7 @@
      *                    needed for determining the allowed range of
      *                    the cutoff frequency
      */
-    BandPassDialog(QWidget *parent, qreal sample_rate);
+    BandPassDialog(QWidget *parent, double sample_rate);
 
     /** Destructor */
     virtual ~BandPassDialog();
@@ -66,10 +66,10 @@
      * Emitted whenever the frequency changes
      * @param freq the frequency parameter in Hz
      */
-    void freqChanged(qreal freq);
+    void freqChanged(double freq);
 
     //* And for the bw
-    void bwChanged(qreal bw);
+    void bwChanged(double bw);
 
     /** Pre-listen mode has been started */
     void startPreListen();
@@ -104,13 +104,13 @@
 private:
 
     /** the cutoff frequency in Hz */
-    qreal m_frequency;
+    double m_frequency;
 
     /** the bw in Hz */
-    qreal m_bw;
+    double m_bw;
 
     /** sample rate of the signal in samples/sec */
-    qreal m_sample_rate;
+    double m_sample_rate;
 
     /** filter function for calculating the frequency response */
     BandPass *m_filter;
Index: plugins/band_pass/BandPassPlugin.cpp
===================================================================
--- a/plugins/band_pass/BandPassPlugin.cpp	(revision 2332)
+++ b/plugins/band_pass/BandPassPlugin.cpp	(revision 2333)
@@ -75,10 +75,10 @@
     if (!dialog) return 0;
 
     // connect the signals for detecting value changes in pre-listen mode
-    connect(dialog, SIGNAL(freqChanged(qreal)),
-            this, SLOT(setFreqValue(qreal)));
-    connect(dialog, SIGNAL(bwChanged(qreal)),
-            this, SLOT(setBwValue(qreal)));
+    connect(dialog, SIGNAL(freqChanged(double)),
+            this, SLOT(setFreqValue(double)));
+    connect(dialog, SIGNAL(bwChanged(double)),
+            this, SLOT(setBwValue(double)));
     return dialog;
 }
 
@@ -98,7 +98,7 @@
 void BandPassPlugin::updateFilter(Kwave::SampleSource *filter,
                                   bool force)
 {
-    qreal sr = signalRate();
+    double sr = signalRate();
 
     if (!filter) return;
 
@@ -121,13 +121,13 @@
 }
 
 //***************************************************************************
-void BandPassPlugin::setFreqValue(qreal frequency)
+void BandPassPlugin::setFreqValue(double frequency)
 {
     m_frequency = frequency;
 }
 
 //***************************************************************************
-void BandPassPlugin::setBwValue(qreal bw)
+void BandPassPlugin::setBwValue(double bw)
 {
     m_bw = bw;
 }
Index: plugins/band_pass/BandPass.cpp
===================================================================
--- a/plugins/band_pass/BandPass.cpp	(revision 2332)
+++ b/plugins/band_pass/BandPass.cpp	(revision 2333)
@@ -46,7 +46,7 @@
 }
 
 //***************************************************************************
-qreal BandPass::at(qreal f)
+double BandPass::at(double f)
 {
     /*
      * filter function as extracted from the aRts code:
@@ -56,7 +56,7 @@
      *
      * convert filter coefficients to our notation:
      */
-    qreal a0, a1, a2, b1, b2;
+    double a0, a1, a2, b1, b2;
     a0 = m_filter.cx;
     a1 = m_filter.cx1;
     a2 = m_filter.cx2;
@@ -68,10 +68,10 @@
      * H(z) = ------------------   | z = e ^ (j*2*pi*f)
      *          z^2 - b1*z - b0
      */
-    std::complex<qreal> h;
-    std::complex<qreal> w;
-    std::complex<qreal> j(0.0,1.0);
-    std::complex<qreal> z;
+    std::complex<double> h;
+    std::complex<double> w;
+    std::complex<double> j(0.0,1.0);
+    std::complex<double> z;
 
     w = f;
     z = std::exp(j*w);
@@ -97,7 +97,7 @@
  * As in ''An introduction to digital filter theory'' by Julius O. Smith
  * and in Moore's book; I use the normalized version in Moore's book.
  */
-void BandPass::setfilter_2polebp(qreal freq, qreal R)
+void BandPass::setfilter_2polebp(double freq, double R)
 {
     m_filter.cx  = 1.0 - R;
     m_filter.cx1 = 0.0;
@@ -134,7 +134,7 @@
 //***************************************************************************
 void BandPass::setFrequency(const QVariant fc)
 {
-    qreal new_freq = QVariant(fc).toDouble();
+    double new_freq = QVariant(fc).toDouble();
     if (new_freq == m_frequency) return; // nothing to do
 
     m_frequency = new_freq;
@@ -145,7 +145,7 @@
 //***************************************************************************
 void BandPass::setBandwidth(const QVariant bw)
 {
-    qreal new_bw = QVariant(bw).toDouble();
+    double new_bw = QVariant(bw).toDouble();
     if (new_bw == m_bandwidth) return; // nothing to do
 
     m_bandwidth = new_bw;
Index: plugins/band_pass/BandPassDialog.cpp
===================================================================
--- a/plugins/band_pass/BandPassDialog.cpp	(revision 2332)
+++ b/plugins/band_pass/BandPassDialog.cpp	(revision 2333)
@@ -35,7 +35,7 @@
 #include "BandPass.h"
 
 //***************************************************************************
-BandPassDialog::BandPassDialog(QWidget *parent, qreal sample_rate)
+BandPassDialog::BandPassDialog(QWidget *parent, double sample_rate)
     :QDialog(parent), KwavePluginSetupDialog(), Ui::BandPassDlg(),
      m_frequency(3500),m_bw(100),
      m_sample_rate(sample_rate), m_filter(0)
@@ -44,7 +44,7 @@
     setModal(true);
 
     // set maximum frequency to sample rate / 2
-    qreal f_max = sample_rate / 2.0;
+    double f_max = sample_rate / 2.0;
 
     slider->setMaximum(static_cast<int>(f_max));
     slider_2->setMaximum(static_cast<int>(f_max / 2.0));
@@ -144,11 +144,11 @@
 {
     // evaluate the parameter list
     bool ok;
-    qreal frequency = params[0].toDouble(&ok);
+    double frequency = params[0].toDouble(&ok);
     Q_ASSERT(ok);
     if (ok) m_frequency = frequency;
 
-    qreal bw = params[1].toDouble(&ok);
+    double bw = params[1].toDouble(&ok);
     Q_ASSERT(ok);
     if (ok) m_bw = bw;
 
@@ -164,7 +164,7 @@
 //***************************************************************************
 void BandPassDialog::updateDisplay()
 {
-    qreal fs = m_sample_rate;
+    double fs = m_sample_rate;
     if (m_filter && (fs > 0.0))
     {
         m_filter->setFrequency(QVariant(2.0 * M_PI * m_frequency / fs));
Index: plugins/codec_wav/RIFFParser.cpp
===================================================================
--- a/plugins/codec_wav/RIFFParser.cpp	(revision 2332)
+++ b/plugins/codec_wav/RIFFParser.cpp	(revision 2333)
@@ -158,11 +158,11 @@
 	    u_int32_t len = 0;
 	    m_dev.read(reinterpret_cast<char *>(&len), 4);
 #if Q_BYTE_ORDER == Q_BIG_ENDIAN
-	    qreal dist_le = fabs(half - bswap_32(len));
-	    qreal dist_be = fabs(half - len);
+	    double dist_le = fabs(half - bswap_32(len));
+	    double dist_be = fabs(half - len);
 #else
-	    qreal dist_le = fabs(half - len);
-	    qreal dist_be = fabs(half - bswap_32(len));
+	    double dist_le = fabs(half - len);
+	    double dist_be = fabs(half - bswap_32(len));
 #endif
 	    // evaluate distance to average length
 	    if (dist_be > dist_le) ++le_matches;
Index: plugins/selectrange/SelectRangeDialog.h
===================================================================
--- a/plugins/selectrange/SelectRangeDialog.h	(revision 2332)
+++ b/plugins/selectrange/SelectRangeDialog.h	(revision 2333)
@@ -49,7 +49,7 @@
      *                      for converting samples to percentage
      */
     SelectRangeDialog(QWidget *widget, Mode start_mode, Mode range_mode,
-                      unsigned int range, qreal sample_rate,
+                      unsigned int range, double sample_rate,
                       unsigned int offset, unsigned int signal_length);
 
     /** Destructor */
Index: plugins/selectrange/SelectRangePlugin.cpp
===================================================================
--- a/plugins/selectrange/SelectRangePlugin.cpp	(revision 2332)
+++ b/plugins/selectrange/SelectRangePlugin.cpp	(revision 2333)
@@ -52,7 +52,7 @@
     interpreteParameters(previous_params);
 
     // create the setup dialog
-    qreal rate = signalRate();
+    double rate = signalRate();
     unsigned int offset = 0;
     selection(&offset, 0, false);
     unsigned int length = signalLength();
Index: plugins/selectrange/SelectRangeDialog.cpp
===================================================================
--- a/plugins/selectrange/SelectRangeDialog.cpp	(revision 2332)
+++ b/plugins/selectrange/SelectRangeDialog.cpp	(revision 2333)
@@ -28,7 +28,7 @@
 
 //***************************************************************************
 SelectRangeDialog::SelectRangeDialog(QWidget *widget,
-    Mode start_mode, Mode range_mode, unsigned int range, qreal sample_rate,
+    Mode start_mode, Mode range_mode, unsigned int range, double sample_rate,
     unsigned int offset, unsigned int signal_length)
     :QDialog(widget), Ui::SelectRangeDlg()
 {
Index: plugins/goto/GotoPlugin.cpp
===================================================================
--- a/plugins/goto/GotoPlugin.cpp	(revision 2332)
+++ b/plugins/goto/GotoPlugin.cpp	(revision 2333)
@@ -50,7 +50,7 @@
     interpreteParameters(previous_params);
 
     // create the setup dialog
-    qreal rate = signalRate();
+    double rate = signalRate();
     unsigned int offset = 0;
     selection(&offset, 0, false);
     unsigned int length = signalLength();
Index: plugins/codec_ogg/OggDecoder.cpp
===================================================================
--- a/plugins/codec_ogg/OggDecoder.cpp	(revision 2332)
+++ b/plugins/codec_ogg/OggDecoder.cpp	(revision 2333)
@@ -439,9 +439,9 @@
 	    const unsigned int stream_end_pos = m_source->pos();
 	    const unsigned int stream_read = stream_end_pos -
 	                                     stream_start_pos + 1;
-	    qreal bits = static_cast<qreal>(stream_read) * 8.0;
-	    qreal seconds = static_cast<qreal>(samples) /
-		static_cast<qreal>(m_info.rate());
+	    double bits = static_cast<double>(stream_read) * 8.0;
+	    double seconds = static_cast<double>(samples) /
+		static_cast<double>(m_info.rate());
 	    bitrate = static_cast<unsigned int>(bits / seconds);
 
 	    // round to neares standard bitrate
Index: plugins/about/LogoWidget.cpp
===================================================================
--- a/plugins/about/LogoWidget.cpp	(revision 2332)
+++ b/plugins/about/LogoWidget.cpp	(revision 2333)
@@ -31,7 +31,7 @@
 #include "LogoWidget.h"
 
 /** increment value of the "h" channel of the color of the sine waves */
-#define COLOR_INCREMENT (static_cast<qreal>(0.001))
+#define COLOR_INCREMENT (static_cast<double>(0.001))
 
 //***************************************************************************
 LogoWidget::LogoWidget(QWidget *parent)
@@ -119,7 +119,7 @@
 	m_color_h += COLOR_INCREMENT; // this gives the nice color change :-)
 	if (m_color_h > 1.0) m_color_h -= 1.0;
 
-	qreal amp = sin(m_deg[MAXSIN - 1] * 3);
+	double amp = sin(m_deg[MAXSIN - 1] * 3);
 	for (int j = 0; j < MAXSIN; j++) {
 	    for (int i=0; i < 21; i++) {
 		si.setPoint(i, (j*m_width/MAXSIN) +
Index: plugins/about/LogoWidget.h
===================================================================
--- a/plugins/about/LogoWidget.h	(revision 2332)
+++ b/plugins/about/LogoWidget.h	(revision 2333)
@@ -73,7 +73,7 @@
     QTimer *m_timer;
 
     /** "H" channel of the sine wave color */
-    qreal m_color_h;
+    double m_color_h;
 };
 
 #endif  /* _LOGO_WIDGET_H_ */
Index: libkwave/FileProgress.cpp
===================================================================
--- a/libkwave/FileProgress.cpp	(revision 2332)
+++ b/libkwave/FileProgress.cpp	(revision 2333)
@@ -38,7 +38,7 @@
 //***************************************************************************
 FileProgress::FileProgress(QWidget *parent,
 	const QUrl &url, unsigned int size,
-	unsigned int samples, qreal rate, unsigned int bits,
+	unsigned int samples, double rate, unsigned int bits,
 	unsigned int tracks)
     :QDialog(parent),
     m_url(url),
@@ -144,7 +144,7 @@
     if (!m_stat_bytes) return;
 
     // some dummy update to get maximum size
-    updateStatistics(9999999.9, static_cast<qreal>(99*24*60*60), size);
+    updateStatistics(9999999.9, static_cast<double>(99*24*60*60), size);
 
     // now correct the minimum sizes of the statistic entries
     m_stat_transfer->adjustSize();
@@ -248,7 +248,7 @@
 }
 
 //***************************************************************************
-void FileProgress::updateStatistics(qreal rate, qreal rest,
+void FileProgress::updateStatistics(double rate, double rest,
 	unsigned int pos)
 {
     QString text;
@@ -304,7 +304,7 @@
 
     // the easiest part: the progress bar and the caption
     int percent = static_cast<int>(
-	static_cast<qreal>(pos) / static_cast<qreal>(m_size) * 100.0);
+	static_cast<double>(pos) / static_cast<double>(m_size) * 100.0);
 
     // not enough progress not worth showing ?
     if (percent <= m_last_percent) return;
@@ -319,11 +319,11 @@
     }
 
     // update the transfer statistics
-    qreal seconds = m_time.elapsed() / 1000.0; // [sec]
-    qreal rate = pos / seconds;                // [bytes/sec]
-    qreal rest = 0;
+    double seconds = m_time.elapsed() / 1000.0; // [sec]
+    double rate = pos / seconds;                // [bytes/sec]
+    double rest = 0;
     if (rate > 10) {
-	rest = qreal(m_size - pos) / rate;     // [seconds]
+	rest = double(m_size - pos) / rate;     // [seconds]
     }
     updateStatistics(rate, rest, pos);
 
Index: libkwave/WindowFunction.cpp
===================================================================
--- a/libkwave/WindowFunction.cpp	(revision 2332)
+++ b/libkwave/WindowFunction.cpp	(revision 2333)
@@ -67,9 +67,9 @@
 }
 
 //***************************************************************************
-QVector<qreal> WindowFunction::points(unsigned int len)
+QVector<double> WindowFunction::points(unsigned int len)
 {
-    QVector<qreal> out(len);
+    QVector<double> out(len);
     Q_ASSERT(out.count() == static_cast<int>(len));
     if (out.count() != static_cast<int>(len)) {
 	out.resize(0);
@@ -89,22 +89,22 @@
 	    break;
 	case WINDOW_FUNC_HAMMING:
 	    for (unsigned int i = 0; i < len; i++)
-		out[i] = 0.54-(0.46 * cos(static_cast<qreal>(i) * 2 * M_PI /
+		out[i] = 0.54-(0.46 * cos(static_cast<double>(i) * 2 * M_PI /
 		         (len - 1)));
 	    break;
 	case WINDOW_FUNC_BLACKMAN:
 	    for (unsigned int i = 0; i < len; i++)
-		out[i] = 0.42-(0.50 * cos(static_cast<qreal>(i) * 2 * M_PI /
+		out[i] = 0.42-(0.50 * cos(static_cast<double>(i) * 2 * M_PI /
 		         (len - 1))) +
-		         (0.08 * cos(static_cast<qreal>(i) * 4 * M_PI /
+		         (0.08 * cos(static_cast<double>(i) * 4 * M_PI /
 		         (len - 1)));
 	    break;
 	case WINDOW_FUNC_TRIANGULAR:
 	    for (unsigned int i = 0; i < len / 2; i++)
-		out[i] = static_cast<qreal>(i) / (len / 2 - 1);
+		out[i] = static_cast<double>(i) / (len / 2 - 1);
 
 	    for (unsigned int i = len / 2; i < len; i++)
-		out[i] = 1 - (static_cast<qreal>(i) - len / 2) / (len / 2 - 1);
+		out[i] = 1 - (static_cast<double>(i) - len / 2) / (len / 2 - 1);
 	    break;
     }
 
Index: libkwave/Curve.cpp
===================================================================
--- a/libkwave/Curve.cpp	(revision 2332)
+++ b/libkwave/Curve.cpp	(revision 2333)
@@ -57,7 +57,7 @@
     QString t = parse.firstParam();
     setInterpolationType(m_interpolation.find(t));
 
-    qreal x, y;
+    double x, y;
     while (!parse.isDone()) {
 	x = parse.toDouble();
 	if (parse.isDone()) break; // half point ?
@@ -88,7 +88,7 @@
 }
 
 //***************************************************************************
-QVector<qreal> Curve::interpolation(unsigned int points)
+QVector<double> Curve::interpolation(unsigned int points)
 {
     m_interpolation.prepareInterpolation(*this);
     return m_interpolation.interpolation(*this, points);
@@ -140,7 +140,7 @@
 }
 
 //***************************************************************************
-void Curve::insert(qreal x, qreal y)
+void Curve::insert(double x, double y)
 {
     if ((x < 0.0) || (x > 1.0)) {
 	qWarning("Curve::insert(%0.2f,%0.2f): out of range !",x,y);
@@ -189,13 +189,13 @@
 //***************************************************************************
 void Curve::scaleFit(unsigned int range)
 {
-    qreal min = DBL_MAX;
-    qreal max = DBL_MIN;
+    double min = DBL_MAX;
+    double max = DBL_MIN;
 
     Interpolation interpolation(m_interpolation.type());
 
-    QVector<qreal> y = interpolation.interpolation(*this, range);
-    foreach (qreal yi, y) {
+    QVector<double> y = interpolation.interpolation(*this, range);
+    foreach (double yi, y) {
 	if (yi > max) max = yi;
 	if (yi < min) min = yi;
     }
@@ -211,11 +211,11 @@
 }
 
 //***************************************************************************
-Curve::Point Curve::findPoint(qreal px, qreal py, qreal tol)
+Curve::Point Curve::findPoint(double px, double py, double tol)
 {
     Point best = NoPoint;
-    qreal dist;
-    qreal min_dist = tol;
+    double dist;
+    double min_dist = tol;
 
     foreach (Point p, *this) {
 	// use the length of the difference vector as criterium
Index: libkwave/Interpolation.cpp
===================================================================
--- a/libkwave/Interpolation.cpp	(revision 2332)
+++ b/libkwave/Interpolation.cpp	(revision 2333)
@@ -95,7 +95,7 @@
 }
 
 //***************************************************************************
-qreal Interpolation::singleInterpolation(qreal input)
+double Interpolation::singleInterpolation(double input)
 {
     if (!count()) return 0.0; // no data ?
 
@@ -112,14 +112,14 @@
 		while ((m_x[i] < input) && (i < count))
 		    i++;
 
-		qreal dif1 = m_x[i] - m_x[i-1];  //!=0 per definition
-		qreal dif2 = input - m_x[i-1];
+		double dif1 = m_x[i] - m_x[i-1];  //!=0 per definition
+		double dif2 = input - m_x[i-1];
 
 		return (m_y[i-1] + ((m_y[i] - m_y[i-1])*dif2 / dif1));
 	    }
 	case INTPOL_SPLINE:
 	    {
-		qreal a, b, diff;
+		double a, b, diff;
 		unsigned int j = 1;
 
 		while ((m_x[j] < input) && (j < count))
@@ -135,7 +135,7 @@
 	    }
 	case INTPOL_NPOLYNOMIAL:
 	    {
-		qreal ny = m_y[0];
+		double ny = m_y[0];
 		for (unsigned int j = 1; j < count; j++)
 		    ny = ny * (input - m_x[j]) + m_y[j];
 		return ny;
@@ -163,9 +163,9 @@
 	if (!m_curve) return 0;
 
 	// use polynom
-	qreal ny;
-	QVector<qreal> ax(7);
-	QVector<qreal> ay(7);
+	double ny;
+	QVector<double> ax(7);
+	QVector<double> ay(7);
 
 	unsigned int i = 1;
 	while ((m_x[i] < input) && (i < count))
@@ -217,10 +217,10 @@
 }
 
 //***************************************************************************
-QVector<qreal> Interpolation::limitedInterpolation(const Curve &points,
-                                                   unsigned int len)
+QVector<double> Interpolation::limitedInterpolation(const Curve &points,
+                                                    unsigned int len)
 {
-    QVector<qreal> y = interpolation(points, len);
+    QVector<double> y = interpolation(points, len);
     for (unsigned int i = 0; i < len; i++) {
 	if (y[i] > 1) y[i] = 1;
 	if (y[i] < 0) y[i] = 0;
@@ -229,21 +229,21 @@
 }
 
 //***************************************************************************
-QVector<qreal> Interpolation::interpolation(const Curve &points,
-                                            unsigned int len)
+QVector<double> Interpolation::interpolation(const Curve &points,
+                                             unsigned int len)
 {
     Q_ASSERT(len);
-    if (!len) return QVector<qreal>();
+    if (!len) return QVector<double>();
 
     unsigned int degree = 0;
-    QVector<qreal> y_out(len);
+    QVector<double> y_out(len);
     qFill(y_out, 0.0);
 
     switch (m_type) {
 	case INTPOL_LINEAR:
 	{
 	    Curve::Point p;
-	    qreal x0, y0, x1, y1;
+	    double x0, y0, x1, y1;
 	    Curve::ConstIterator it(points);
 
 	    if (it.hasNext()) {
@@ -256,7 +256,7 @@
 		    x1 = p.x();
 		    y1 = p.y();
 
-		    qreal dy = (y1 - y0);
+		    double dy = (y1 - y0);
 		    int dx  = static_cast<int>((x1 - x0) * len);
 		    int min = static_cast<int>(x0 * len);
 
@@ -264,7 +264,7 @@
 		    Q_ASSERT(x1 <= 1.0);
 		    for (int i = static_cast<int>(x0 * len);
 		         i < static_cast<int>(x1 * len); i++) {
-			qreal h = dx ? ((qreal(i - min)) / dx) : 0.0;
+			double h = dx ? ((double(i - min)) / dx) : 0.0;
 			y_out[i] = y0 + (h * dy);
 		    }
 		    x0 = x1;
@@ -278,10 +278,10 @@
 	    int t = 1;
 	    unsigned int count = points.count();
 
-	    qreal ny = 0;
-	    QVector<qreal> der(count + 1);
-	    QVector<qreal> x(count + 1);
-	    QVector<qreal> y(count + 1);
+	    double ny = 0;
+	    QVector<double> der(count + 1);
+	    QVector<double> x(count + 1);
+	    QVector<double> y(count + 1);
 
 	    Curve::ConstIterator it(points);
 	    while (it.hasNext()) {
@@ -299,8 +299,8 @@
 	    for (unsigned int j = 2; j <= count; j++) {
 		ent = static_cast<int>(x[j] * len);
 		for (int i = start; i < ent; i++) {
-		    qreal xin = static_cast<qreal>(i) / len;
-		    qreal h, b, a;
+		    double xin = static_cast<double>(i) / len;
+		    double h, b, a;
 
 		    h = x[j] - x[j - 1];
 
@@ -327,10 +327,10 @@
 	{
 	    if (!degree) degree = 7;
 	    unsigned int count = points.count();
-	    qreal ny;
-	    QVector<qreal> x(7);
-	    QVector<qreal> y(7);
-	    qreal ent, start;
+	    double ny;
+	    QVector<double> x(7);
+	    QVector<double> y(7);
+	    double ent, start;
 
 	    if (count) {
 		for (unsigned int px = 0; px < count - 1; px++) {
@@ -347,7 +347,7 @@
 		    {
 			ny = y[0];
 			for (unsigned int j = 1; j < degree; j++)
-			    ny = ny * ((static_cast<qreal>(i)) / len - x[j])
+			    ny = ny * ((static_cast<double>(i)) / len - x[j])
 				+ y[j];
 
 			y_out[i] = ny;
@@ -358,18 +358,18 @@
 	}
 	case INTPOL_NPOLYNOMIAL:
 	{
-	    qreal ny;
+	    double ny;
 	    int count = points.count();
 
 	    if (count != 0) {
-		QVector<qreal> x(count+1);
-		QVector<qreal> y(count+1);
-		qreal px;
+		QVector<double> x(count+1);
+		QVector<double> y(count+1);
+		double px;
 
 		createFullPolynom(points, x, y);
 
 		for (unsigned int i = 1; i < len; i++) {
-		    px = static_cast<qreal>(i) / len;
+		    px = static_cast<double>(i) / len;
 		    ny = y[0];
 		    for (int j = 1; j < count; j++)
 			ny = ny * (px - x[j]) + y[j];
@@ -381,7 +381,7 @@
 	}
 	case INTPOL_SAH:
 	{
-	    qreal x0, y0, x1, y1;
+	    double x0, y0, x1, y1;
 
 	    Curve::ConstIterator it(points);
 	    if (it.hasNext()) {
@@ -410,7 +410,7 @@
 
 //***************************************************************************
 void Interpolation::createFullPolynom(const Curve &points,
-	QVector<qreal> &x, QVector<qreal> &y)
+	QVector<double> &x, QVector<double> &y)
 {
     Q_ASSERT(!points.isEmpty());
     Q_ASSERT(m_curve);
@@ -437,15 +437,15 @@
 }
 
 //***************************************************************************
-void Interpolation::get2Derivate(const QVector<qreal> &x,
-	const QVector<qreal> &y, QVector<qreal> &ab, unsigned int n)
+void Interpolation::get2Derivate(const QVector<double> &x,
+	const QVector<double> &y, QVector<double> &ab, unsigned int n)
 {
     Q_ASSERT(n);
     if (!n) return;
 
     unsigned int i, k;
-    qreal p, qn, sig, un;
-    QVector<qreal> u(n);
+    double p, qn, sig, un;
+    QVector<double> u(n);
 
     ab[0] = ab[1] = 0;
     u[0] = u[1] = 0;
@@ -470,7 +470,7 @@
 
 //***************************************************************************
 void Interpolation::createPolynom(const Curve &points,
-                                  QVector<qreal> &x, QVector<qreal> &y,
+                                  QVector<double> &x, QVector<double> &y,
                                   int pos, unsigned int degree)
 {
     unsigned int count = 0;
Index: libkwave/modules/KwaveOsc.cpp
===================================================================
--- a/libkwave/modules/KwaveOsc.cpp	(revision 2332)
+++ b/libkwave/modules/KwaveOsc.cpp	(revision 2333)
@@ -35,12 +35,12 @@
 void Kwave::Osc::goOn()
 {
     unsigned int samples = m_buffer.size();
-    const qreal two_pi = 2.0 * M_PI;
+    const double two_pi = 2.0 * M_PI;
 
     Q_ASSERT(m_f != 0);
     if (m_f == 0) return;
 
-    qreal omega = two_pi / m_f;
+    double omega = two_pi / m_f;
     for (unsigned int sample = 0; sample < samples; sample++) {
 	// calculate one sample as sin(w * t)
 	m_buffer[sample] = double2sample(m_a * sin(m_omega_t));
Index: libkwave/modules/KwaveOsc.h
===================================================================
--- a/libkwave/modules/KwaveOsc.h	(revision 2332)
+++ b/libkwave/modules/KwaveOsc.h	(revision 2333)
@@ -73,13 +73,13 @@
 	    Kwave::SampleArray m_buffer;
 
 	    /** current time multiplied by 2*Pi*f */
-	    qreal m_omega_t;
+	    double m_omega_t;
 
 	    /** frequency [samples/period] */
-	    qreal m_f;
+	    double m_f;
 
 	    /** amplitude [0...1] */
-	    qreal m_a;
+	    double m_a;
     };
 }
 
Index: libkwave/Filter.h
===================================================================
--- a/libkwave/Filter.h	(revision 2332)
+++ b/libkwave/Filter.h	(revision 2333)
@@ -77,14 +77,14 @@
      * Returns a filter coefficient.
      * @param index internal index [0...count-1]
      */
-    qreal coeff(unsigned int index);
+    double coeff(unsigned int index);
 
     /**
      * Sets a filter coefficient to a new value.
      * @param index internal index [0...count-1]
      * @param newval new coefficient
      */
-    void setCoeff(unsigned int index, qreal newval);
+    void setCoeff(unsigned int index, double newval);
 
     /**
      * Returns a delay time of the filter.
@@ -113,7 +113,7 @@
     unsigned int m_rate;
 
     /** array of coefficients */
-    QVector<qreal> m_coeff;
+    QVector<double> m_coeff;
 
     /** array of delay times */
     QVector<int> m_delay;
Index: libkwave/FileProgress.h
===================================================================
--- a/libkwave/FileProgress.h	(revision 2332)
+++ b/libkwave/FileProgress.h	(revision 2333)
@@ -49,7 +49,7 @@
      */
     FileProgress(QWidget *parent,
 	const QUrl &url, unsigned int size,
-	unsigned int samples, qreal rate, unsigned int bits,
+	unsigned int samples, double rate, unsigned int bits,
 	unsigned int tracks);
 
     /** Destructor */
@@ -136,7 +136,7 @@
      * @param pos position in the file
      * @internal
      */
-    void updateStatistics(qreal rate, qreal rest, unsigned int pos);
+    void updateStatistics(double rate, double rest, unsigned int pos);
 
 protected:
 
@@ -174,7 +174,7 @@
     unsigned int m_bits_per_sample;
 
     /** number of samples per second, used for output */
-    qreal m_sample_rate;
+    double m_sample_rate;
 
     /** number of tracks */
     unsigned int m_tracks;
Index: libkwave/Filter.cpp
===================================================================
--- a/libkwave/Filter.cpp	(revision 2332)
+++ b/libkwave/Filter.cpp	(revision 2333)
@@ -103,14 +103,14 @@
 }
 
 //***************************************************************************
-qreal Filter::coeff(unsigned int index)
+double Filter::coeff(unsigned int index)
 {
     Q_ASSERT(static_cast<int>(index) < m_coeff.count());
     return m_coeff[index];
 }
 
 //***************************************************************************
-void Filter::setCoeff(unsigned int index, qreal newval)
+void Filter::setCoeff(unsigned int index, double newval)
 {
     Q_ASSERT(static_cast<int>(index) < m_coeff.count());
     m_coeff[index] = newval;
Index: libkwave/Curve.h
===================================================================
--- a/libkwave/Curve.h	(revision 2332)
+++ b/libkwave/Curve.h	(revision 2333)
@@ -104,7 +104,7 @@
      * @param x coordinate on the x axis, should be [0...+1.0]
      * @param y coordinate on the y axis, should be [0...+1.0]
      */
-    void insert(qreal x, qreal y);
+    void insert(double x, double y);
 
     /**
      * Searches for a point at given coordinates with a definable
@@ -114,7 +114,7 @@
      * @param tol tolerance for x and y direction, absolute value
      * @return pointer to the found point or "NoPoint" if nothing found.
      */
-    Point findPoint(qreal x, qreal y, qreal tol = .05);
+    Point findPoint(double x, double y, double tol = .05);
 
     /**
      * Sets a curve from a command string. Opposite of getCommand().
@@ -150,7 +150,7 @@
      * @return Array of interpolated values or null if the
      *         number of points was zero or the curve was empty.
      */
-    QVector<qreal> interpolation(unsigned int points);
+    QVector<double> interpolation(unsigned int points);
 
 protected:
 
Index: libkwave/KwavePlugin.cpp
===================================================================
--- a/libkwave/KwavePlugin.cpp	(revision 2332)
+++ b/libkwave/KwavePlugin.cpp	(revision 2333)
@@ -401,7 +401,7 @@
 }
 
 //***************************************************************************
-qreal Kwave::Plugin::signalRate()
+double Kwave::Plugin::signalRate()
 {
     return manager().signalRate();
 }
@@ -450,7 +450,7 @@
 }
 
 //***************************************************************************
-QString Kwave::Plugin::zoom2string(qreal percent)
+QString Kwave::Plugin::zoom2string(double percent)
 {
     QString result = "";
 
@@ -471,7 +471,7 @@
 }
 
 //***************************************************************************
-QString Kwave::Plugin::ms2string(qreal ms, int precision)
+QString Kwave::Plugin::ms2string(double ms, int precision)
 {
     char buf[128];
     int bufsize = 128;
@@ -493,7 +493,7 @@
 	if (m < 1) {
 	    char format[128];
 	    int digits = static_cast<int>(
-		ceil(static_cast<qreal>(precision+1) - log10(ms)));
+		ceil(static_cast<double>(precision+1) - log10(ms)));
 	    snprintf(format, sizeof(format), "%%0.%df s", digits);
 	    snprintf(buf, bufsize, format, ms / 1000.0);
 	} else {
Index: libkwave/KwavePlugin.h
===================================================================
--- a/libkwave/KwavePlugin.h	(revision 2332)
+++ b/libkwave/KwavePlugin.h	(revision 2333)
@@ -210,7 +210,7 @@
 	* Returns the sample rate of the current signal. If no signal is
 	* present the return value will be zero.
 	*/
-	virtual qreal signalRate();
+	virtual double signalRate();
 
 	/**
 	* Returns an array of indices of currently selected channels.
@@ -258,7 +258,7 @@
 	* @param percent the zoom factor to be formated, a value of "100.0"
 	*             means "100%", "0.1" means "0.1%" and so on.
 	*/
-	static QString zoom2string(qreal percent);
+	static QString zoom2string(double percent);
 
 	/**
 	* Converts a time in milliseconds into a string. Times below one
@@ -273,7 +273,7 @@
 	*                  must be >= 3 !
 	* @return time formatted as user-readable string
 	*/
-	static QString ms2string(qreal ms, int precision = 6);
+	static QString ms2string(double ms, int precision = 6);
 
 	/**
 	* Converts the given number into a string with the current locale's
Index: libkwave/WindowFunction.h
===================================================================
--- a/libkwave/WindowFunction.h	(revision 2332)
+++ b/libkwave/WindowFunction.h	(revision 2333)
@@ -59,7 +59,7 @@
      * the given number of points. This is similar to Kwave's
      * Interpolation class.
      */
-    QVector<qreal> points(unsigned int len);
+    QVector<double> points(unsigned int len);
 
     /**
      * Returns the window function id through it's numeric index. If
Index: libkwave/Interpolation.h
===================================================================
--- a/libkwave/Interpolation.h	(revision 2332)
+++ b/libkwave/Interpolation.h	(revision 2333)
@@ -53,14 +53,14 @@
 
     bool prepareInterpolation(const Curve &points);
 
-    QVector<qreal> interpolation(const Curve &points, unsigned int len);
+    QVector<double> interpolation(const Curve &points, unsigned int len);
 
-    QVector<qreal> limitedInterpolation(const Curve &points, unsigned int len);
+    QVector<double> limitedInterpolation(const Curve &points, unsigned int len);
 
     /**
      * Returns a single point of the interpolation.
      */
-    qreal singleInterpolation(qreal pos);
+    double singleInterpolation(double pos);
 
     /**
      * Same as getSingleInterpolation, but return value
@@ -69,7 +69,7 @@
      * @param pos ???
      * @return interpolated value [0...1]
      */
-    qreal singleLimitedInterpolation(qreal pos);
+    double singleLimitedInterpolation(double pos);
 
     /**
      * Returns the if of a type through it's name.
@@ -135,8 +135,8 @@
      * @param y receives all y coordinates ???
      */
     void createFullPolynom(const Curve &points,
-                           QVector<qreal> &x,
-                           QVector<qreal> &y);
+                           QVector<double> &x,
+                           QVector<double> &y);
 
     /**
      * ???
@@ -145,9 +145,9 @@
      * @param ab array for return values
      * @param n ???
      */
-    void get2Derivate(const QVector<qreal> &x,
-                      const QVector<qreal> &y,
-                      QVector<qreal> &ab, unsigned int n);
+    void get2Derivate(const QVector<double> &x,
+                      const QVector<double> &y,
+                      QVector<double> &ab, unsigned int n);
 
     /**
      * ???
@@ -158,8 +158,8 @@
      * @param degree ???
      */
     void createPolynom (const Curve &points,
-                        QVector<qreal> &x,
-                        QVector<qreal> &y,
+                        QVector<double> &x,
+                        QVector<double> &y,
                         int pos, unsigned int degree);
 
 private:
@@ -168,13 +168,13 @@
     const Curve *m_curve;
 
     /** ??? used for temporary purposes */
-    QVector<qreal> m_x;
+    QVector<double> m_x;
 
     /** ??? used for temporary purposes */
-    QVector<qreal> m_y;
+    QVector<double> m_y;
 
     /** ??? used for temporary purposes */
-    QVector<qreal> m_der;
+    QVector<double> m_der;
 
     /** Map with type and name of interpolations */
     static InterpolationMap m_interpolation_map;
Index: libgui/LabelPropertiesWidget.cpp
===================================================================
--- a/libgui/LabelPropertiesWidget.cpp	(revision 2332)
+++ b/libgui/LabelPropertiesWidget.cpp	(revision 2333)
@@ -54,7 +54,7 @@
 
 //***************************************************************************
 void LabelPropertiesWidget::setLabelPosition(unsigned int pos,
-	unsigned int length, qreal rate)
+	unsigned int length, double rate)
 {
     Q_ASSERT(time);
     if (!time) return;
Index: libgui/SelectTimeWidget.h
===================================================================
--- a/libgui/SelectTimeWidget.h	(revision 2332)
+++ b/libgui/SelectTimeWidget.h	(revision 2333)
@@ -59,7 +59,7 @@
      * @param signal_length length of the signal in samples, needed
      *                      for converting samples to percentage
      */
-    virtual void init(Mode mode, unsigned int range, qreal sample_rate,
+    virtual void init(Mode mode, unsigned int range, double sample_rate,
                       unsigned int offset, unsigned int signal_length);
 
     /** Destructor */
@@ -89,7 +89,7 @@
      * @return time converted to samples
      */
     static unsigned int timeToSamples(Mode mode, unsigned int time,
-                                      qreal rate, unsigned int length);
+                                      double rate, unsigned int length);
 
     /**
      * Conversion from samples into time
@@ -100,7 +100,7 @@
      * @return time converted to the given mode
      */
     static unsigned int samplesToTime(Mode mode, unsigned int time,
-                                      qreal rate, unsigned int length);
+                                      double rate, unsigned int length);
 
 signals:
 
@@ -151,7 +151,7 @@
     unsigned int m_range;
 
     /** sample rate [samples/second] */
-    qreal m_rate;
+    double m_rate;
 
     /** start offset of the selectioh [samples] */
     unsigned int m_offset;
Index: libgui/SignalWidget.cpp
===================================================================
--- a/libgui/SignalWidget.cpp	(revision 2332)
+++ b/libgui/SignalWidget.cpp	(revision 2333)
@@ -614,7 +614,7 @@
 }
 
 //***************************************************************************
-void SignalWidget::newSignal(unsigned int samples, qreal rate,
+void SignalWidget::newSignal(unsigned int samples, double rate,
                              unsigned int bits, unsigned int tracks)
 {
     close();
@@ -670,7 +670,7 @@
 }
 
 //***************************************************************************
-qreal SignalWidget::getFullZoom()
+double SignalWidget::getFullZoom()
 {
     if (m_signal_manager.isEmpty()) return 0.0;    // no zoom if no signal
 
@@ -687,14 +687,14 @@
     //          -> 49.5 [pixels / sample]
     //          -> zoom = 1 / 49.5 [samples / pixel]
     // => full zoom [samples/pixel] = (length-1) / (width-1)
-    return static_cast<qreal>(length - 1) /
-	   static_cast<qreal>(QWidget::width() - 1);
+    return static_cast<double>(length - 1) /
+	   static_cast<double>(QWidget::width() - 1);
 }
 
 //***************************************************************************
-void SignalWidget::setZoom(qreal new_zoom)
+void SignalWidget::setZoom(double new_zoom)
 {
-    qreal old_zoom = m_zoom;
+    double old_zoom = m_zoom;
     InhibitRepaintGuard inhibit(*this);
 
     m_zoom = new_zoom;
@@ -719,8 +719,8 @@
 //***************************************************************************
 void SignalWidget::fixZoomAndOffset()
 {
-    qreal max_zoom;
-    qreal min_zoom;
+    double max_zoom;
+    double min_zoom;
     unsigned int length;
 
     length = m_signal_manager.length();
@@ -736,8 +736,8 @@
 
     // ensure that the zoom is in a proper range
     max_zoom = getFullZoom();
-    min_zoom = static_cast<qreal>(MINIMUM_SAMPLES_PER_SCREEN) /
-	       static_cast<qreal>(m_width);
+    min_zoom = static_cast<double>(MINIMUM_SAMPLES_PER_SCREEN) /
+	       static_cast<double>(m_width);
     if (m_zoom < min_zoom) m_zoom = min_zoom;
     if (m_zoom > max_zoom) m_zoom = max_zoom;
 
@@ -775,7 +775,7 @@
 //    // adjust the zoom factor in order to make a whole number
 //    // of samples fit into the current window
 //    int samples = pixels2samples(width) + 1;
-//    zoom = (qreal)(samples) / (qreal)(width - 1);
+//    zoom = (double)(samples) / (double)(width - 1);
 
     // do some final range checking
     if (m_zoom < min_zoom) m_zoom = min_zoom;
@@ -863,7 +863,7 @@
 
     if (len) {
 	m_offset = ofs;
-	setZoom((static_cast<qreal>(len)) / static_cast<qreal>(m_width - 1));
+	setZoom((static_cast<double>(len)) / static_cast<double>(m_width - 1));
     }
 }
 
@@ -1453,7 +1453,7 @@
 
 //***************************************************************************
 void SignalWidget::showPosition(const QString &text, unsigned int pos,
-                                qreal ms, const QPoint &mouse)
+                                double ms, const QPoint &mouse)
 {
     int x = mouse.x();
     int y = mouse.y();
@@ -1848,18 +1848,18 @@
 }
 
 //***************************************************************************
-unsigned int SignalWidget::ms2samples(qreal ms)
+unsigned int SignalWidget::ms2samples(double ms)
 {
     return static_cast<unsigned int>(
 	rint(ms * m_signal_manager.rate() / 1E3));
 }
 
 //***************************************************************************
-qreal SignalWidget::samples2ms(unsigned int samples)
+double SignalWidget::samples2ms(unsigned int samples)
 {
-    qreal rate = m_signal_manager.rate();
+    double rate = m_signal_manager.rate();
     if (rate == 0.0) return 0.0;
-    return static_cast<qreal>(samples) * 1E3 / rate;
+    return static_cast<double>(samples) * 1E3 / rate;
 }
 
 //***************************************************************************
@@ -1867,14 +1867,14 @@
 {
     if ((pixels < 0) || (m_zoom <= 0.0)) return 0;
     return static_cast<unsigned int>(rint(
-	static_cast<qreal>(pixels) * m_zoom));
+	static_cast<double>(pixels) * m_zoom));
 }
 
 //***************************************************************************
 int SignalWidget::samples2pixels(int samples) const
 {
     if (m_zoom == 0.0) return 0;
-    return static_cast<int>(rint(static_cast<qreal>(samples) / m_zoom));
+    return static_cast<int>(rint(static_cast<double>(samples) / m_zoom));
 }
 
 //***************************************************************************
@@ -2262,10 +2262,10 @@
 //	int high = signalmanage->getRate() / parser.toInt();
 //	int low = signalmanage->getRate() / parser.toInt();
 //	int octave = parser.toBool ("true");
-//	qreal adjust = parser.toDouble ();
+//	double adjust = parser.toDouble ();
 //
 //	for (int i = 0; i < AUTOKORRWIN; i++)
-//	    autotable[i] = 1 - (((qreal)i * i * i) / (AUTOKORRWIN * AUTOKORRWIN * AUTOKORRWIN));    //generate static weighting function
+//	    autotable[i] = 1 - (((double)i * i * i) / (AUTOKORRWIN * AUTOKORRWIN * AUTOKORRWIN));    //generate static weighting function
 //
 //	if (octave) for (int i = 0; i < AUTOKORRWIN; i++) weighttable[i] = 1;    //initialise moving weight table
 //
@@ -2318,13 +2318,13 @@
 ////returns length of period, if found
 //{
 //    int i, j;
-//    qreal gmax = 0, max, c;
+//    double gmax = 0, max, c;
 //    int maxpos = AUTOKORRWIN;
 //    int down, up;         //flags
 //
 //    max = 0;
 //    for (j = 0; j < AUTOKORRWIN; j++)
-//	gmax += ((qreal)sample[j]) * sample [j];
+//	gmax += ((double)sample[j]) * sample [j];
 //
 //    //correlate signal with itself for finding maximum integral
 //
@@ -2334,7 +2334,7 @@
 //    max = 0;
 //    while (i < AUTOKORRWIN) {
 //	c = 0;
-//	for (j = 0; j < AUTOKORRWIN; j++) c += ((qreal)sample[j]) * sample [i + j];
+//	for (j = 0; j < AUTOKORRWIN; j++) c += ((double)sample[j]) * sample [i + j];
 //	c = c * autotable[i];    //multiply window with weight for preference of high frequencies
 //	if (c > max) max = c, maxpos = i;
 //	i++;
@@ -2343,18 +2343,18 @@
 //}
 //
 ////*****************************************************************************
-//int findNextRepeatOctave (int *sample, int high, qreal adjust = 1.005)
+//int findNextRepeatOctave (int *sample, int high, double adjust = 1.005)
 ////autocorellation of a windowed part of the sample
 ////same as above only with an adaptive weighting to decrease fast period changes
 //{
 //    int i, j;
-//    qreal gmax = 0, max, c;
+//    double gmax = 0, max, c;
 //    int maxpos = AUTOKORRWIN;
 //    int down, up;         //flags
 //
 //    max = 0;
 //    for (j = 0; j < AUTOKORRWIN; j++)
-//	gmax += ((qreal)sample[j]) * sample [j];
+//	gmax += ((double)sample[j]) * sample [j];
 //
 //    //correlate signal with itself for finding maximum integral
 //
@@ -2364,7 +2364,7 @@
 //    max = 0;
 //    while (i < AUTOKORRWIN) {
 //	c = 0;
-//	for (j = 0; j < AUTOKORRWIN; j++) c += ((qreal)sample[j]) * sample [i + j];
+//	for (j = 0; j < AUTOKORRWIN; j++) c += ((double)sample[j]) * sample [i + j];
 //	c = c * autotable[i] * weighttable[i];
 //	//multiply window with weight for preference of high frequencies
 //	if (c > max) max = c, maxpos = i;
@@ -2526,7 +2526,7 @@
 
     const unsigned int first = m_signal_manager.selection().first();
     const unsigned int last  = m_signal_manager.selection().last();
-    const qreal        rate  = m_signal_manager.rate();
+    const double       rate  = m_signal_manager.rate();
     const unsigned int bits  = m_signal_manager.bits();
 
     MultiTrackReader src(m_signal_manager,
Index: libgui/TrackPixmap.cpp
===================================================================
--- a/libgui/TrackPixmap.cpp	(revision 2332)
+++ b/libgui/TrackPixmap.cpp	(revision 2333)
@@ -220,7 +220,7 @@
 }
 
 //***************************************************************************
-void TrackPixmap::setZoom(qreal zoom)
+void TrackPixmap::setZoom(double zoom)
 {
     QMutexLocker lock(&m_lock_buffer);
 
@@ -427,7 +427,7 @@
 }
 
 //***************************************************************************
-void TrackPixmap::setVerticalZoom(qreal zoom)
+void TrackPixmap::setVerticalZoom(double zoom)
 {
     QMutexLocker lock(&m_lock_buffer);
 
@@ -459,7 +459,7 @@
     Q_ASSERT(width() <= static_cast<int>(m_max_buffer.size()));
 
     // scale_y: pixels per unit
-    qreal scale_y = (m_vertical_zoom * static_cast<qreal>(height)) /
+    double scale_y = (m_vertical_zoom * static_cast<double>(height)) /
 	(1 << SAMPLE_BITS);
     int max = 0, min = 0;
 
@@ -564,8 +564,8 @@
     if (m_zoom == 0.0) return;
 
     // scale_y: pixels per unit
-    scale_y = (m_vertical_zoom * static_cast<qreal>(height)) /
-	static_cast<qreal>((SAMPLE_MAX + 1) << 1);
+    scale_y = (m_vertical_zoom * static_cast<double>(height)) /
+	static_cast<double>((SAMPLE_MAX + 1) << 1);
 
     // N: order of the filter, at least 2 * (1/m_zoom)
     N = INTERPOLATION_PRECISION * samples2pixels(1);
@@ -643,15 +643,15 @@
 void TrackPixmap::drawPolyLineSignal(QPainter &p, int width,
 	int middle, int height)
 {
-    qreal scale_y;
+    double scale_y;
     int y;
     unsigned int sample;
     int x;
     unsigned int buflen = m_sample_buffer.size();
 
     // scale_y: pixels per unit
-    scale_y = (m_vertical_zoom * static_cast<qreal>(height)) /
-	static_cast<qreal>((SAMPLE_MAX + 1) << 1);
+    scale_y = (m_vertical_zoom * static_cast<double>(height)) /
+	static_cast<double>((SAMPLE_MAX + 1) << 1);
 
     // array with sample points
     QPolygon points;
Index: libgui/CurveWidget.h
===================================================================
--- a/libgui/CurveWidget.h	(revision 2332)
+++ b/libgui/CurveWidget.h	(revision 2333)
@@ -56,7 +56,7 @@
      * @param x the point's x coordinate, should be [0.0...1.0]
      * @param y the point's y coordinate, should be [0.0...1.0]
      */
-    void addPoint(qreal x, qreal y);
+    void addPoint(double x, double y);
 
     /**
      * Tries to find a point that is nearest to the given widget coordinates
Index: libgui/SelectTimeWidget.cpp
===================================================================
--- a/libgui/SelectTimeWidget.cpp	(revision 2332)
+++ b/libgui/SelectTimeWidget.cpp	(revision 2333)
@@ -40,7 +40,7 @@
 }
 
 //***************************************************************************
-void SelectTimeWidget::init(Mode mode, unsigned int range, qreal sample_rate,
+void SelectTimeWidget::init(Mode mode, unsigned int range, double sample_rate,
                             unsigned int offset, unsigned int signal_length)
 {
     m_mode  = mode;
@@ -458,7 +458,7 @@
 
 //***************************************************************************
 unsigned int SelectTimeWidget::timeToSamples(
-    Mode mode, unsigned int time, qreal rate, unsigned int length)
+    Mode mode, unsigned int time, double rate, unsigned int length)
 {
     unsigned int pos = 0;
     switch (mode) {
@@ -484,7 +484,7 @@
 
 //***************************************************************************
 unsigned int SelectTimeWidget::samplesToTime(
-    Mode mode, unsigned int samples, qreal rate, unsigned int length)
+    Mode mode, unsigned int samples, double rate, unsigned int length)
 {
     unsigned int time = 0;
 
Index: libgui/OverViewWidget.cpp
===================================================================
--- a/libgui/OverViewWidget.cpp	(revision 2332)
+++ b/libgui/OverViewWidget.cpp	(revision 2333)
@@ -158,7 +158,7 @@
     if (!width) return 0;
 
     int offset = static_cast<int>(m_signal_length *
-	(static_cast<qreal>(pixels) / static_cast<qreal>(width)));
+	(static_cast<double>(pixels) / static_cast<double>(width)));
     int center = m_view_width >> 1;
     offset = (offset > center) ? (offset - center) : 0;
     return offset;
Index: libgui/SignalWidget.h
===================================================================
--- a/libgui/SignalWidget.h	(revision 2332)
+++ b/libgui/SignalWidget.h	(revision 2333)
@@ -97,7 +97,7 @@
      * @param ms time in milliseconds
      * @return number of samples (rounded)
      */
-    unsigned int ms2samples(qreal ms);
+    unsigned int ms2samples(double ms);
 
     /**
      * Converts a number of samples to a time in milliseconds, based on the
@@ -105,7 +105,7 @@
      * @param samples number of samples
      * @return time in milliseconds
      */
-    qreal samples2ms(unsigned int samples);
+    double samples2ms(unsigned int samples);
 
     /**
      * Closes the current signal and loads a new one from a file.
@@ -119,7 +119,7 @@
      * signal manager.
      * @see TopWidget::newSignal
      */
-    void newSignal(unsigned int samples, qreal rate,
+    void newSignal(unsigned int samples, double rate,
                    unsigned int bits, unsigned int tracks);
 
     /**
@@ -133,7 +133,7 @@
      *                 to [length/width...1/width] (from full display to
      *                 one visible sample only)
      */
-    void setZoom(qreal new_zoom);
+    void setZoom(double new_zoom);
 
     /**
      * Checks if a pixel position is near to the left or right border
@@ -224,7 +224,7 @@
     /**
      * Returns the current number of pixels per sample
      */
-    inline qreal zoom() { return m_zoom; }
+    inline double zoom() { return m_zoom; }
 
     /** Returns the width of the current view in samples */
     int displaySamples();
@@ -589,7 +589,7 @@
      * into the current window.
      * @return zoom value [samples/pixel]
      */
-    qreal getFullZoom();
+    double getFullZoom();
 
     /** slot for detecting resizing of the widget */
     virtual void resizeEvent(QResizeEvent *);
@@ -675,7 +675,7 @@
      * @param mouse the coordinates of the mouse cursor,
      *              relative to this widget [pixel]
      */
-    void showPosition(const QString &text, unsigned int pos, qreal ms,
+    void showPosition(const QString &text, unsigned int pos, double ms,
                       const QPoint &mouse);
 
     /** Shortcut for accessing the label list @note can be modified */
@@ -724,10 +724,10 @@
     int m_last_height;
 
     /** number of samples per pixel */
-    qreal m_zoom;
+    double m_zoom;
 
     /** vertical zoom factor */
-    qreal m_vertical_zoom;
+    double m_vertical_zoom;
 
     /**
      * position of the vertical line that indicates the current
Index: libgui/CurveWidget.cpp
===================================================================
--- a/libgui/CurveWidget.cpp	(revision 2332)
+++ b/libgui/CurveWidget.cpp	(revision 2333)
@@ -298,7 +298,7 @@
 }
 
 //***************************************************************************
-void CurveWidget::addPoint(qreal newx, qreal newy)
+void CurveWidget::addPoint(double newx, double newy)
 {
     m_curve.insert(newx, newy);
     m_last = Curve::NoPoint;
@@ -313,8 +313,8 @@
     Q_ASSERT(m_height > 1);
     if ((m_width <= 1) || (m_width <= 1)) return Curve::NoPoint;
 
-    return m_curve.findPoint((static_cast<qreal>(sx)) / (m_width-1),
-	(static_cast<qreal>(m_height) - sy) / (m_height-1));
+    return m_curve.findPoint((static_cast<double>(sx)) / (m_width-1),
+	(static_cast<double>(m_height) - sy) / (m_height-1));
 }
 
 //***************************************************************************
@@ -335,8 +335,8 @@
 	m_current = findPoint(e->pos().x(), e->pos().y());
 	if (m_current == Curve::NoPoint) {
 	    // no matching point is found -> generate a new one !
-	    addPoint(static_cast<qreal>(e->pos().x()) / (m_width-1),
-		     static_cast<qreal>(m_height - e->pos().y()) /
+	    addPoint(static_cast<double>(e->pos().x()) / (m_width-1),
+		     static_cast<double>(m_height - e->pos().y()) /
 		     (m_height-1));
 	    m_current = findPoint(e->pos().x(), e->pos().y());
 	}
@@ -371,15 +371,15 @@
 
 	m_curve.deletePoint(m_current, false);
 
-	m_current.setX(static_cast<qreal>(x) / (m_width-1));
-	m_current.setY(static_cast<qreal>(m_height - y) / (m_height-1));
+	m_current.setX(static_cast<double>(x) / (m_width-1));
+	m_current.setY(static_cast<double>(m_height - y) / (m_height-1));
 
 	if (m_current.x() < 0.0) m_current.setX(0.0);
 	if (m_current.y() < 0.0) m_current.setY(0.0);
 	if (m_current.x() > 1.0) m_current.setX(1.0);
 	if (m_current.y() > 1.0) m_current.setY(1.0);
 
-	qreal dx = (1.0 / static_cast<qreal>(m_width-1));
+	double dx = (1.0 / static_cast<double>(m_width-1));
 	do {
 	    Curve::Point nearest = m_curve.findPoint(
 		m_current.x(), m_current.y(), 1.0);
@@ -418,7 +418,7 @@
     const int kw = m_knob.width();
     const int kh = m_knob.height();
 
-    QVector<qreal> y = m_curve.interpolation(m_width);
+    QVector<double> y = m_curve.interpolation(m_width);
     Q_ASSERT(static_cast<int>(y.count()) == m_width);
     if (static_cast<int>(y.count()) < m_width) {
 	qWarning("CurveWidget: unable to get interpolation !");
Index: libgui/TrackPixmap.h
===================================================================
--- a/libgui/TrackPixmap.h	(revision 2332)
+++ b/libgui/TrackPixmap.h	(revision 2333)
@@ -105,7 +105,7 @@
      * Sets a new vertical zoom factor.
      * @param zoom new vertical zoom
      */
-    virtual void setVerticalZoom(qreal zoom);
+    virtual void setVerticalZoom(double zoom);
 
     /**
      * Returns "true" if the buffer has changed and the pixmap has to
@@ -136,7 +136,7 @@
      * affects the number of visible samples and a redraw of
      * the current view.
      */
-    void setZoom(qreal zoom);
+    void setZoom(double zoom);
 
 private slots:
 
@@ -318,12 +318,12 @@
      * Zoom factor in samples/pixel. Needed for converting
      * sample indices into pixels and vice-versa.
      */
-    qreal m_zoom;
+    double m_zoom;
 
     /**
      * vertical zoom factor. Default is 1.0
      */
-    qreal m_vertical_zoom;
+    double m_vertical_zoom;
 
     /**
      * If true, we are in min/max mode. This means that m_sample_buffer
Index: libgui/FrequencyResponseWidget.h
===================================================================
--- a/libgui/FrequencyResponseWidget.h	(revision 2332)
+++ b/libgui/FrequencyResponseWidget.h	(revision 2333)
@@ -50,7 +50,7 @@
      * @param db_min lowest amplitude in decibel
      * @param db_max highest amplitude in decibel
      */
-    virtual void init(qreal freq, int db_min, int db_max);
+    virtual void init(double freq, int db_min, int db_max);
 
     /** Set a new transmission function and update the display */
     virtual void setFilter(TransmissionFunction *func);
@@ -61,7 +61,7 @@
 private:
 
     /** highest frequency, rounded up to the next decade */
-    qreal m_f_max;
+    double m_f_max;
 
     /** lowest amplitude in decibel */
     int m_db_min;
